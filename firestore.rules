/**
 * Core Philosophy: This ruleset enforces a Role-Based Access Control (RBAC) model. A user's role (Admin, PM, or Technician), stored on their user document, is the primary determinant of their permissions. Admins have broad administrative access, Project Managers (PMs) can manage sites and their related data, and Technicians can interact with their assigned PM sessions and tasks.
 * Data Structure: The data is organized hierarchically, with most operational data nested under the `/sites/{siteId}` collection. This includes PM assignments, site-specific tasks, PM sessions, and change requests. A top-level `/users` collection stores user profiles and roles, and a global `/tasks` collection holds static tasks applicable to all sites.
 * Key Security Decisions:
 * - Role-based authorization is central. Most rules perform a `get()` request to `/users/{request.auth.uid}` to retrieve the user's role for the current request.
 * - User privacy is enforced by disallowing users from listing or viewing other user profiles; they can only manage their own.
 * - Technicians' access is narrowly scoped to the specific PM sessions they are assigned to, which is verified by checking the `technicianId` on the parent `pmSession` document.
 * Denormalization for Authorization: The model depends on the `role` field denormalized onto each document in the `/users` collection. Additionally, `pmId` on `PmAssignment` and `technicianId` on `PmSession` are critical for linking users to resources and enabling efficient security rules.
 * Structural Segregation: Static (global) tasks are stored in a separate top-level `/tasks` collection, while dynamic (site-specific) tasks are nested under `/sites/{siteId}/tasks`. This separation allows for distinct and simpler security rules for each type of task.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for concise and readable rules
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Checks for document existence, critical for safe updates and deletes.
    function isExistingDoc() {
      return resource != null;
    }

    // Retrieves the authenticated user's role from their user document.
    function getUserRole() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }

    function isAdmin() {
      return isSignedIn() && getUserRole() == 'Admin';
    }

    function isPM() {
      return isSignedIn() && getUserRole() == 'PM';
    }
    
    // Checks if the requesting user is the technician assigned to a specific PM Session.
    // This requires a 'get' call to the parent session document.
    function isAssignedTechnician(siteId, pmAssignmentId, pmSessionId) {
        let sessionData = get(/databases/$(database)/documents/sites/$(siteId)/pmAssignments/$(pmAssignmentId)/pmSessions/$(pmSessionId)).data;
        return isSignedIn() && sessionData.technicianId == request.auth.uid;
    }

    /**
     * @description Controls access to user profile data.
     * @path /users/{userId}
     * @allow A user (auth.uid='user123') creates their own profile document at `/users/user123`. (create)
     * @deny An authenticated user (auth.uid='user456') tries to read another user's profile at `/users/user123`. (get)
     * @principle Restricts access to a user's own data tree, a fundamental privacy and security measure.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isExistingDoc() && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(userId) && isExistingDoc();
    }

    /**
     * @description Controls access to top-level site documents and their nested subcollections.
     * @path /sites/{siteId}
     * @allow A user with the 'PM' role reads the list of all sites. (list)
     * @deny A user with the 'Technician' role tries to create a new site document. (create)
     * @principle Implements role-based access control, where Admins and PMs have oversight of sites.
     */
    match /sites/{siteId} {
      allow get: if isAdmin() || isPM();
      allow list: if isAdmin() || isPM();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();

      /**
       * @description Controls access to PM assignments for a specific site.
       * @path /sites/{siteId}/pmAssignments/{pmAssignmentId}
       * @allow An 'Admin' user creates a new PM assignment for a site. (create)
       * @deny A 'Technician' user attempts to delete a PM assignment. (delete)
       * @principle Enforces role-based management (Admin/PM) while allowing the assigned PM to modify their own assignment.
       */
      match /pmAssignments/{pmAssignmentId} {
        allow get: if isAdmin() || isPM();
        allow list: if isAdmin() || isPM();
        allow create: if (isAdmin() || isPM()) && request.resource.data.siteId == siteId;
        allow update: if (isAdmin() || isOwner(resource.data.pmId)) && isExistingDoc();
        allow delete: if (isAdmin() || isOwner(resource.data.pmId)) && isExistingDoc();

        /**
         * @description Controls access to PM sessions within a specific assignment.
         * @path /sites/{siteId}/pmAssignments/{pmAssignmentId}/pmSessions/{pmSessionId}
         * @allow A 'PM' user reads a PM session document to check its status. (get)
         * @deny A 'Technician' tries to list all sessions for an assignment they are not part of. (list)
         * @principle Access is granted to managing roles (Admin/PM) and the specific user assigned as the technician.
         */
        match /pmSessions/{pmSessionId} {
          allow get: if isAdmin() || isPM() || isOwner(resource.data.technicianId);
          allow list: if isAdmin() || isPM();
          allow create: if (isAdmin() || isPM()) && request.resource.data.pmAssignmentId == pmAssignmentId;
          allow update: if (isAdmin() || isPM()) && isExistingDoc();
          allow delete: if (isAdmin() || isPM()) && isExistingDoc();

          /**
           * @description Controls access to task results recorded during a PM session.
           * @path /sites/{siteId}/pmAssignments/{pmAssignmentId}/pmSessions/{pmSessionId}/taskResults/{taskResultId}
           * @allow The assigned technician (auth.uid matches parent session's technicianId) creates a new task result. (create)
           * @deny A user who is not the assigned technician or an admin tries to update a task result. (update)
           * @principle Ensures only the assigned technician can record task outcomes, with Admins retaining oversight.
           */
          match /taskResults/{taskResultId} {
            allow get: if isAdmin() || isPM() || isAssignedTechnician(siteId, pmAssignmentId, pmSessionId);
            allow list: if isAdmin() || isPM() || isAssignedTechnician(siteId, pmAssignmentId, pmSessionId);
            allow create: if isAssignedTechnician(siteId, pmAssignmentId, pmSessionId) && request.resource.data.pmSessionId == pmSessionId;
            allow update: if (isAdmin() || isAssignedTechnician(siteId, pmAssignmentId, pmSessionId)) && isExistingDoc();
            allow delete: if (isAdmin() || isAssignedTechnician(siteId, pmAssignmentId, pmSessionId)) && isExistingDoc();
          }
        }
      }

      /**
       * @description Controls access to dynamic, site-specific tasks.
       * @path /sites/{siteId}/tasks/{taskId}
       * @allow A user with the 'PM' role creates a new task specific to the site '/sites/site123'. (create)
       * @deny A user with the 'Technician' role attempts to delete a site-specific task. (delete)
       * @principle Grants site management roles (Admin/PM) control over tasks unique to that site.
       */
      match /tasks/{taskId} {
        allow get: if isAdmin() || isPM();
        allow list: if isAdmin() || isPM();
        allow create: if (isAdmin() || isPM()) && request.resource.data.siteId == siteId;
        allow update: if (isAdmin() || isPM()) && isExistingDoc();
        allow delete: if (isAdmin() || isPM()) && isExistingDoc();
      }

      /**
       * @description Controls access to change requests for a specific site.
       * @path /sites/{siteId}/changeRequests/{changeRequestId}
       * @allow A 'PM' user updates the status of an existing change request. (update)
       * @deny A 'Technician' user tries to create a new change request. (create)
       * @principle Restricts the management of change requests to roles with site oversight (Admin/PM).
       */
      match /changeRequests/{changeRequestId} {
        allow get: if isAdmin() || isPM();
        allow list: if isAdmin() || isPM();
        allow create: if (isAdmin() || isPM()) && request.resource.data.siteId == siteId;
        allow update: if (isAdmin() || isPM()) && isExistingDoc();
        allow delete: if (isAdmin() || isPM()) && isExistingDoc();
      }
    }

    /**
     * @description Controls access to the global, static task list.
     * @path /tasks/{taskId}
     * @allow Any signed-in user, such as a 'Technician', reads the list of all static tasks. (list)
     * @deny A user with the 'PM' role attempts to create a new static task. (create)
     * @principle Allows all authenticated users to read common task data, but reserves write access for Admins.
     */
    match /tasks/{taskId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }
  }
}